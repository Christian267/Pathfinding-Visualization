{"version":3,"sources":["components/Node/Node.jsx","algorithms/PriorityQueue.js","algorithms/dijkstra2.js","algorithms/aStar.js","algorithms/depthFirst.js","algorithms/breadthFirst.js","algorithms/mazeGeneratorOLD.js","components/DropdownMenu/DropdownMenu.jsx","MazeSolvingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","col","isFinish","isStart","isWall","weight","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","parent","i","left","right","PriorityQueue","comparator","a","b","_heap","_comparator","length","size","values","forEach","value","push","_siftUp","poppedValue","peek","bottom","_swap","pop","_siftDown","replacedValue","j","node","_greater","maxChild","dijkstra","grid","startNode","finishNode","queue","distance","visitedNodesInOrder","neighborsAlreadyInQueue","isEmpty","currentNode","isVisited","currentViableNeighbors","getUnvisitedNeighbors","neighbor","includes","updateNeighbors","getNodesInShortestPathOrder","nodesInShortestPath","unshift","previousNode","neighbors","filter","aStar","finishRow","finishCol","distanceFromFinish","Math","abs","depthFirstSearch","allVisitedNodes","processNode","randomIndex","floor","random","splice","newNodes","newNode","breadthFirstSearch","console","log","shift","mazeAlgorithm","DropdownMenu","ref","React","createRef","menuText","defaultTitle","isOpen","menuHeight","handleOpenMenu","bind","algorithm","setState","changeMenuText","handler","items","listItems","map","item","index","key","onClick","handlerAndMenuText","href","dropdownContent","PathFindingVisualizer","createNode","Infinity","getEmptyGrid","currentRow","mouseIsPressed","disableButtonsAndGridWhileAnimating","holdingEndNode","blockTypeToBePlaced","draggingStartNode","draggingFinishNode","algorithmAlreadyVisualized","visualizeAlgorithm","clearGrid","clearVisitedNodes","saveWallsAndWeights","placeWallsAndWeights","handleChooseAlgorithm","handleChooseBlockType","fillGridWithWalls","document","title","blockType","newGrid","getNewGridWithWallToggled","getNewGridWithWeightToggled","previousStartNode","newNodeElement","getElementById","previousRow","previousCol","previousNodeElement","setTimeout","visualizeNoAnimation","clearStartAndFinishDuplicates","previousFinishNode","nodesInShortestPathOrder","lastVisitedNode","at","loopLength","animateShortestPath","shortestPathNoAnimation","currentNodeElement","nodeClassName","blockCoordinatesAndType","resetNodeProperties","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","animateAlgorithm","algorithmNoAnimation","visitedWallInOrder","placeFillerWalls","visitedWallsInOrder","defaultDropdownTitles","disabled","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","slice","newWeight","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ade2301d.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      weight,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : weight === 4\r\n      ? \"node-weight-4\"\r\n      : weight === 3\r\n      ? \"node-weight-3\"\r\n      : weight === 2\r\n      ? \"node-weight-2\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      />\r\n    );\r\n  }\r\n}\r\n","const top = 0;\r\nconst parent = i => ((i + 1) >>> 1) - 1;\r\nconst left = i => (i << 1) + 1;\r\nconst right = i => (i + 1) << 1;\r\n\r\nexport default class PriorityQueue {\r\n  constructor(comparator = (a, b) => a < b) {\r\n    this._heap = [];\r\n    this._comparator = comparator;\r\n  }\r\n  size() {\r\n    return this._heap.length;\r\n  }\r\n  isEmpty() {\r\n    return this.size() === 0;\r\n  }\r\n  peek() {\r\n    return this._heap[top];\r\n  }\r\n  push(...values) {\r\n    values.forEach(value => {\r\n      this._heap.push(value);\r\n      this._siftUp();\r\n    });\r\n    return this.size();\r\n  }\r\n  pop() {\r\n    const poppedValue = this.peek();\r\n    const bottom = this.size() - 1;\r\n    if (bottom > top) {\r\n      this._swap(top, bottom);\r\n    }\r\n    this._heap.pop();\r\n    this._siftDown();\r\n    return poppedValue;\r\n  }\r\n  replace(value) {\r\n    const replacedValue = this.peek();\r\n    this._heap[top] = value;\r\n    this._siftDown();\r\n    return replacedValue;\r\n  }\r\n  _greater(i, j) {\r\n    return this._comparator(this._heap[i], this._heap[j]);\r\n  }\r\n  _swap(i, j) {\r\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\r\n  }\r\n  _siftUp() {\r\n    let node = this.size() - 1;\r\n    while (node > top && this._greater(node, parent(node))) {\r\n      this._swap(node, parent(node));\r\n      node = parent(node);\r\n    }\r\n  }\r\n  _siftDown() {\r\n    let node = top;\r\n    while (\r\n      (left(node) < this.size() && this._greater(left(node), node)) ||\r\n      (right(node) < this.size() && this._greater(right(node), node))\r\n    ) {\r\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\r\n      this._swap(node, maxChild);\r\n      node = maxChild;\r\n    }\r\n  }\r\n}","import PriorityQueue from \"./PriorityQueue\";\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const queue = new PriorityQueue();\r\n    startNode.distance = 1000;\r\n    const visitedNodesInOrder = [];\r\n    const neighborsAlreadyInQueue = [];\r\n    queue.push([startNode, startNode.distance]);\r\n    while (!queue.isEmpty()) {\r\n        const currentNode = queue.pop()[0];\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n        const currentViableNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for (const neighbor of currentViableNeighbors) {\r\n            if (!(neighborsAlreadyInQueue.includes(neighbor))){\r\n                updateNeighbors(neighbor, currentNode);\r\n                neighborsAlreadyInQueue.push(neighbor);\r\n                queue.push([neighbor, neighbor.distance]);\r\n            }\r\n        }\r\n        if (currentNode === finishNode) {\r\n            return visitedNodesInOrder;\r\n\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    const viableNeighbors = neighbors.filter((neighbor) => !(neighbor.isVisited || neighbor.isWall));\r\n    return viableNeighbors;\r\n}\r\n\r\nfunction updateNeighbors(neighbor, node) {\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    neighbor.previousNode = node;\r\n}","import PriorityQueue from \"./PriorityQueue\";\r\n\r\nexport function aStar(grid, startNode, finishNode) {\r\n    const queue = new PriorityQueue();\r\n    startNode.distance = 1000;\r\n    const visitedNodesInOrder = [];\r\n    const neighborsAlreadyInQueue = [];\r\n    const finishRow = finishNode.row;\r\n    const finishCol = finishNode.col;\r\n    queue.push([startNode, startNode.distance]);\r\n    while (!queue.isEmpty()) {\r\n        const currentNode = queue.pop()[0];\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n        const currentViableNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for (const neighbor of currentViableNeighbors) {\r\n            if (!neighborsAlreadyInQueue.includes(neighbor)){\r\n                updateNeighbors(neighbor, currentNode);\r\n                neighborsAlreadyInQueue.push(neighbor);\r\n                const distanceFromFinish = Math.abs(neighbor.row - finishRow) + Math.abs(neighbor.col - finishCol) + 1000;\r\n                if (neighbor.weight > 1) {\r\n                    queue.push([neighbor, 51 * neighbor.distance + 50 * distanceFromFinish + neighbor.weight * 25]);\r\n                }\r\n                else queue.push([neighbor, 51 * neighbor.distance + 50 * distanceFromFinish]);\r\n            }\r\n        }\r\n        if (currentNode === finishNode) {\r\n            return visitedNodesInOrder;\r\n\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    const viableNeighbors = neighbors.filter((neighbor) => !(neighbor.isVisited || neighbor.isWall));\r\n    return viableNeighbors;\r\n}\r\n\r\nfunction updateNeighbors(neighbor, node) {\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    neighbor.previousNode = node;\r\n    \r\n}","export function depthFirstSearch(grid, startNode) {\r\n    const visitedNodesInOrder = [];\r\n    const allVisitedNodes = [];\r\n    allVisitedNodes.push(...processNode(startNode, grid));\r\n    for (const node of allVisitedNodes){\r\n        visitedNodesInOrder.push(node);\r\n        if (node.isFinish) return visitedNodesInOrder;\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction processNode(node, grid) {\r\n    if (node.isFinish) return [node];\r\n    const visitedNodesInOrder = [];\r\n    node.isVisited = true;\r\n    const neighbors = getUnvisitedNeighbors(node, grid);\r\n    if (neighbors.length === 0) {\r\n        visitedNodesInOrder.push(node);\r\n        return visitedNodesInOrder;\r\n    }\r\n    while (neighbors.length > 0) {\r\n        const randomIndex = Math.floor(Math.random() * neighbors.length);\r\n        const neighbor = neighbors.splice(randomIndex, 1)[0];\r\n        if (neighbor.previousNode === null) neighbor.previousNode = node;\r\n        const newNodes = processNode(neighbor, grid);\r\n        for (const newNode of newNodes) {\r\n            if(!visitedNodesInOrder.includes(newNode)) {\r\n                visitedNodesInOrder.push(newNode);\r\n            }\r\n        }\r\n    }\r\n    visitedNodesInOrder.unshift(node);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    const viableNeighbors = neighbors.filter((neighbor) => !(neighbor.isVisited || neighbor.isWall));\r\n    return viableNeighbors;\r\n}\r\n","export function breadthFirstSearch(grid, startNode, finishNode){\r\n    const queue = [startNode];\r\n    const visitedNodesInOrder = [];\r\n    while (queue.length > 0) {\r\n        console.log(\"Current Queue: \" + queue)\r\n        const currentNode = queue.shift();\r\n        console.log(\"Current Node: \" + currentNode);\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n        const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        console.log(\"Current Neighbors: \" + neighbors);\r\n        for (const neighbor of neighbors) { \r\n            if (!queue.includes(neighbor)) {\r\n                console.log(\"Neighbor: \" + neighbor);\r\n                neighbor.previousNode = currentNode;\r\n                queue.push(neighbor);\r\n            }\r\n        }\r\n        if (currentNode == finishNode) { \r\n            return visitedNodesInOrder;\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    const viableNeighbors = neighbors.filter((neighbor) => !(neighbor.isVisited || neighbor.isWall));\r\n    return viableNeighbors;\r\n}","export function mazeAlgorithm(grid, startNode) {\r\n    const visitedNodesInOrder = [];\r\n    visitedNodesInOrder.push(...processNode(startNode, grid));\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction processNode(node, grid) {\r\n    const visitedNodesInOrder = [];\r\n    node.isWall = true;\r\n    const neighbors = getUnvisitedNeighbors(node, grid);\r\n    if (neighbors.length === 0) {\r\n        visitedNodesInOrder.push(node);\r\n        return visitedNodesInOrder;\r\n    }\r\n    while (neighbors.length > 0) {\r\n        const randomIndex = Math.floor(Math.random() * neighbors.length);\r\n        const neighbor = neighbors.splice(randomIndex, 1)[0];\r\n        const newNodes = processNode(neighbor, grid);\r\n        for (const newNode of newNodes) {\r\n            if(!visitedNodesInOrder.includes(newNode)) visitedNodesInOrder.push(newNode);\r\n        }\r\n    }\r\n    visitedNodesInOrder.unshift(node);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    const viableNeighbors = neighbors.filter((neighbor) => !(neighbor.isWall));\r\n    return viableNeighbors;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./DropdownMenu.css\";\r\n\r\nexport default class DropdownMenu extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.ref = React.createRef();\r\n    this.state = {\r\n      menuText: this.props.defaultTitle,\r\n      isOpen: false,\r\n      menuHeight: null,\r\n    };\r\n    this.handleOpenMenu = this.handleOpenMenu.bind(this);\r\n  }\r\n  \r\n\r\n  changeMenuText(algorithm) {\r\n    this.setState({menuText: algorithm,\r\n    isOpen: false});\r\n  }\r\n\r\n  handlerAndMenuText(algorithm) {\r\n    this.changeMenuText(algorithm);\r\n    this.props.handler(algorithm);\r\n  }\r\n\r\n  handleOpenMenu() {\r\n    this.setState((state) => ({\r\n      isOpen: !state.isOpen,\r\n    }));\r\n  }\r\n\r\n  render() {\r\n    var items = this.props.listItems.map((item, index) =>\r\n      <a \r\n      key={index} \r\n      onClick={() => this.handlerAndMenuText(item)}\r\n      ref={this.ref}\r\n      href=\"/Pathfinding-Visualization/\"\r\n      >\r\n        {item}\r\n      </a>);\r\n    var dropdownContent = \r\n    <div id=\"dropdownContent\" className={\"dropdownContent \" + this.props.extraClassName}>\r\n      {items}\r\n    </div>;\r\n    const extraClassName = this.state.isOpen ?\r\n                             \"Open\" :\r\n                             \"\";\r\n\r\n    return (\r\n      <><button id=\"dropdownButton\"\r\n        className={\"dropdownButton\" + extraClassName} \r\n        onClick={() => this.handleOpenMenu()}\r\n        >\r\n          {this.state.menuText}\r\n        </button>\r\n        {this.state.isOpen && dropdownContent}\r\n      </>\r\n    );\r\n  }\r\n}","import React, { Component } from \"react\";\r\nimport Node from \"../components/Node/Node\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/dijkstra2\";\r\nimport { aStar } from \"../algorithms/aStar\";\r\nimport { depthFirstSearch } from \"../algorithms/depthFirst\";\r\nimport { breadthFirstSearch } from \"../algorithms/breadthFirst\";\r\nimport { mazeAlgorithm } from \"../algorithms/mazeGeneratorOLD\";\r\nimport DropdownMenu from \"../components/DropdownMenu/DropdownMenu.jsx\";\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nconst NUMROWS = 31;\r\nconst NUMCOLS = 60;\r\n\r\nexport default class PathFindingVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.ref = React.createRef();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      disableButtonsAndGridWhileAnimating: false,\r\n      holdingEndNode: false,\r\n      startNode: {\r\n        row: 14,\r\n        col: 19\r\n      },\r\n      finishNode: {\r\n        row: 14,\r\n        col: 40\r\n      },\r\n      blockTypeToBePlaced: \"Wall\",\r\n      algorithm: \"Dijkstra\",\r\n      draggingStartNode: false,\r\n      draggingFinishNode: false,\r\n      algorithmAlreadyVisualized: false,\r\n    };\r\n    this.visualizeAlgorithm = this.visualizeAlgorithm.bind(this);\r\n    this.clearGrid = this.clearGrid.bind(this);\r\n    this.clearVisitedNodes = this.clearVisitedNodes.bind(this);\r\n    this.saveWallsAndWeights = this.saveWallsAndWeights.bind(this);\r\n    this.placeWallsAndWeights = this.placeWallsAndWeights.bind(this);\r\n    this.handleChooseAlgorithm = this.handleChooseAlgorithm.bind(this);\r\n    this.handleChooseBlockType = this.handleChooseBlockType.bind(this);\r\n    this.fillGridWithWalls = this.fillGridWithWalls.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getEmptyGrid();\r\n    document.title = \"Pathfinding Visualizer\";\r\n    this.setState((state) => ({\r\n      grid: grid,\r\n    }));\r\n  }\r\n\r\n  handleChooseAlgorithm(algorithm) {\r\n    this.setState({\r\n      algorithm: algorithm,\r\n    });\r\n  }\r\n\r\n  handleChooseBlockType(blockType) {\r\n    this.setState ({\r\n      blockTypeToBePlaced: blockType,\r\n    });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const gridIsDisabled = this.state.disableButtonsAndGridWhileAnimating;\r\n    if (gridIsDisabled) return;\r\n    const startNode = this.state.startNode;\r\n    const finishNode = this.state.finishNode;\r\n    if (row === startNode.row && col === startNode.col) {\r\n      this.setState({\r\n        draggingStartNode: true,\r\n        mouseIsPressed: true,\r\n      });\r\n    }\r\n    else if (row === finishNode.row && col === finishNode.col){\r\n      this.setState({\r\n        draggingFinishNode: true,\r\n        mouseIsPressed: true,\r\n      });\r\n    }\r\n    else {\r\n      const blockType = this.state.blockTypeToBePlaced\r\n      if (blockType === \"Wall\"){\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ \r\n          grid: newGrid, \r\n          mouseIsPressed: true });    \r\n      }\r\n      else if (blockType === \"Weight\") {\r\n        const newGrid = getNewGridWithWeightToggled(this.state.grid, row, col, 0);\r\n        this.setState({ \r\n          grid: newGrid, \r\n          mouseIsPressed: true });\r\n        }\r\n      }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    const { grid } = this.state;\r\n    const gridIsDisabled = this.state.disableButtonsAndGridWhileAnimating;\r\n    if (gridIsDisabled) return;\r\n    if(this.state.draggingStartNode && \r\n       grid[row][col].isWall === false &&\r\n       grid[row][col].isFinish === false) {\r\n      const previousStartNode = this.state.startNode;\r\n      const newNode = grid[row][col];\r\n      const newNodeElement = document.getElementById(`node-${newNode.row}-${newNode.col}`);\r\n      const previousRow = previousStartNode.row;\r\n      const previousCol = previousStartNode.col;\r\n      const previousNodeElement = document.getElementById(`node-${previousRow}-${previousCol}`);\r\n\r\n      grid[previousRow][previousCol].isStart = false;\r\n      grid[row][col].isStart = true;\r\n      setTimeout(() => {\r\n        this.setState({\r\n          grid: grid,\r\n          startNode:{\r\n            row: row,\r\n            col: col,\r\n          },\r\n        })\r\n      }, 0);\r\n      setTimeout(() => {\r\n        if (this.state.algorithmAlreadyVisualized) {\r\n          previousNodeElement.className = `node node-visited-no-animation`;\r\n          this.visualizeNoAnimation();\r\n        }\r\n        else this.clearStartAndFinishDuplicates();\r\n        newNodeElement.className = `node node-start`;\r\n        \r\n      }, 0);\r\n    }\r\n    else if (this.state.draggingFinishNode && grid[row][col].isWall === false) {\r\n      const previousFinishNode = this.state.finishNode;\r\n      const newNode = grid[row][col];\r\n      const newNodeElement = document.getElementById(`node-${newNode.row}-${newNode.col}`);\r\n      const previousRow = previousFinishNode.row;\r\n      const previousCol = previousFinishNode.col;\r\n      grid[previousRow][previousCol].isFinish = false;\r\n      grid[row][col].isFinish = true;\r\n      setTimeout(() => {\r\n        this.setState({\r\n          grid: grid,\r\n          finishNode:{\r\n            row: row,\r\n            col: col,\r\n          },\r\n        })\r\n      }, 0);\r\n      setTimeout(() => {\r\n        if (this.state.algorithmAlreadyVisualized) this.visualizeNoAnimation();\r\n        this.clearStartAndFinishDuplicates();\r\n        newNodeElement.className = `node node-finish`\r\n      }, 0);\r\n    }\r\n    else if (!this.state.draggingFinishNode && !this.state.draggingStartNode) {\r\n      if (!this.state.mouseIsPressed) return;\r\n      const blockType = this.state.blockTypeToBePlaced;\r\n      if (blockType === \"Wall\"){\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid,});\r\n      }\r\n      else if (blockType === \"Weight\") {\r\n        const newGrid = getNewGridWithWeightToggled(this.state.grid, row, col, 0);\r\n        this.setState({ grid: newGrid,});\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ \r\n      mouseIsPressed: false,\r\n      draggingStartNode: false,\r\n      draggingFinishNode: false,\r\n    });\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const lastVisitedNode = visitedNodesInOrder.at(-1);\r\n    const finishNode = this.state.finishNode;\r\n    var loopLength = visitedNodesInOrder.length;\r\n    if (lastVisitedNode.row === finishNode.row && lastVisitedNode.col === finishNode.col){\r\n      loopLength--;\r\n    }\r\n    for (let i = 1; i <= loopLength; i++) {\r\n      if (i === loopLength) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 20 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const currentNodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n        currentNodeElement.className = node.weight===1\r\n          ? `node node-visited`\r\n          : `node node-visited node-weight-${node.weight}`;\r\n      }, 20 * i);\r\n    }\r\n  }\r\n\r\n  algorithmNoAnimation(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const lastVisitedNode = visitedNodesInOrder.at(-1);\r\n    const finishNode = this.state.finishNode;\r\n    var loopLength = visitedNodesInOrder.length;\r\n    if (lastVisitedNode.row === finishNode.row && lastVisitedNode.col === finishNode.col){\r\n      loopLength--;\r\n    }\r\n    for (let i = 1; i <= loopLength; i++) {\r\n      if (i === loopLength) {\r\n        this.shortestPathNoAnimation(nodesInShortestPathOrder);\r\n        return;\r\n      }\r\n      const node = visitedNodesInOrder[i];\r\n      const currentNodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n      const nodeClassName = currentNodeElement.className;\r\n      if(nodeClassName === `node node-visited` || \r\n         nodeClassName === `node node-visited node-weight ${node.weight}` ||\r\n         nodeClassName === `node node-visited-no-animation`||\r\n         nodeClassName === `node node-visited-no-animation node-weight-${node.weight}`) {\r\n        continue;\r\n      }\r\n        currentNodeElement.className = node.weight===1\r\n        ? `node node-visited-no-animation`\r\n        : `node node-visited-no-animation node-weight-${node.weight}`;\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length-1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        const currentNodeElement = document.getElementById(\r\n          `node-${node.row}-${node.col}`);\r\n        currentNodeElement.className = node.weight===1\r\n          ? `node node-shortest-path`\r\n          : `node node-shortest-path node-weight-${node.weight}`;\r\n      }, 25 * i);\r\n    }\r\n    setTimeout(() => {\r\n      this.setState({disableButtonsAndGridWhileAnimating: false})\r\n    }, 25 * nodesInShortestPathOrder.length);\r\n  }\r\n\r\n  shortestPathNoAnimation(nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= nodesInShortestPathOrder.length-2; i++) {\r\n      const node = nodesInShortestPathOrder[i];\r\n      const currentNodeElement = document.getElementById(\r\n        `node-${node.row}-${node.col}`);\r\n      currentNodeElement.className = node.weight===1\r\n        ? `node node-shortest-path-no-animation`\r\n        : `node node-shortest-path-no-animation node-weight-${node.weight}`;\r\n  }\r\n  }\r\n\r\n  /**\r\n   * Called when the \"Visualize Algorithm\" button on the UI is clicked.\r\n   */\r\n  visualizeAlgorithm() {\r\n    const blockCoordinatesAndType = this.saveWallsAndWeights();\r\n    setTimeout(() => {\r\n    this.clearVisitedNodes()\r\n    this.resetNodeProperties()\r\n    this.clearGrid()\r\n    this.placeWallsAndWeights(blockCoordinatesAndType)\r\n    }, 0);\r\n    const { grid } = this.state;\r\n    const startNodeRow = this.state.startNode.row;\r\n    const startNodeCol = this.state.startNode.col;\r\n    const finishNodeRow = this.state.finishNode.row;\r\n    const finishNodeCol = this.state.finishNode.col;\r\n    const startNode = grid[startNodeRow][startNodeCol]\r\n    const finishNode = grid[finishNodeRow][finishNodeCol];\r\n    const algorithm = this.state.algorithm;\r\n    var visitedNodesInOrder = [];\r\n    setTimeout(() => {\r\n      if (algorithm === \"Dijkstra\") visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n      else if (algorithm === \"A Star\") visitedNodesInOrder = aStar(grid, startNode, finishNode);\r\n      else if (algorithm === \"Breadth First\") visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n      else if(algorithm === \"Depth First\") visitedNodesInOrder = depthFirstSearch(grid, startNode);\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      this.setState({\r\n      algorithmAlreadyVisualized: true,\r\n      disableButtonsAndGridWhileAnimating: true});\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder)\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Called in handleMouseEnter() when the either endpoint is dragged and an algorithm has already been visualized\r\n   * Utilized when dragging endpoints on the grid to quickly update the pathFinding algorithm \r\n   * visualization without re-animating the algorithm\r\n   */\r\n  visualizeNoAnimation(){\r\n    setTimeout(() => {\r\n      this.resetNodeProperties();\r\n      }, 0);\r\n      setTimeout(() => {\r\n        const { grid } = this.state;  \r\n      const startNodeRow = this.state.startNode.row;\r\n      const startNodeCol = this.state.startNode.col;\r\n      const finishNodeRow = this.state.finishNode.row;\r\n      const finishNodeCol = this.state.finishNode.col;\r\n      const startNode = grid[startNodeRow][startNodeCol];\r\n      const finishNode = grid[finishNodeRow][finishNodeCol];\r\n      var visitedNodesInOrder = null;\r\n      const algorithm = this.state.algorithm;\r\n      this.clearVisitedNodes();\r\n      if (algorithm === \"Dijkstra\") visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n      else if (algorithm === \"A Star\") visitedNodesInOrder = aStar(grid, startNode, finishNode);\r\n      else if (algorithm === \"Breadth First\") visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n      else if(algorithm === \"Depth First\") visitedNodesInOrder = depthFirstSearch(grid, startNode);\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      this.algorithmNoAnimation(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Utilized in visualizeAlgorithm() to maintain walls when repeating animation\r\n   * @return {Array[Array[int][int][int]]} [[row, col]][weight]\r\n   */\r\n  saveWallsAndWeights() {\r\n    var blockCoordinatesAndType = [];\r\n    const { grid } = this.state;\r\n    for (let row = 0; row < NUMROWS; row++) {\r\n      for (let col = 0; col < NUMCOLS; col++) {\r\n        if ((row === this.state.startNode.row && col === this.state.startNode.col) ||\r\n        (row === this.state.finishNode.row && col === this.state.finishNode.col)){\r\n            continue;\r\n            }\r\n        const currentNode = grid[row][col];\r\n        if (currentNode.isWall) {\r\n          blockCoordinatesAndType.push([row, col, 0]);\r\n        }\r\n        else if (currentNode.weight > 1){\r\n          blockCoordinatesAndType.push([row, col, currentNode.weight]);\r\n        }\r\n      }\r\n    }\r\n    return blockCoordinatesAndType;  //[row, col, isWall]\r\n  }\r\n\r\n  /**\r\n   * Utilized in visualizeAlgorithm() to maintain walls and weights in conjunction with \r\n   * saveWallsAndWeights() after clearGrid() is called. \r\n   * @param {Array[Array[int][int]][int]} blockCoordinatesAndType \r\n   */\r\n  placeWallsAndWeights(blockCoordinatesAndType) {\r\n    var { grid } = this.state;\r\n    for (let i = 0; i < blockCoordinatesAndType.length; i++) {\r\n      const row = blockCoordinatesAndType[i][0];\r\n      const col = blockCoordinatesAndType[i][1];\r\n      const currentNode = grid[row][col];\r\n      const currentNodeElement = document.getElementById(`node-${row}-${col}`);\r\n      if (blockCoordinatesAndType[i][2] === 0){\r\n        grid = getNewGridWithWallToggled(grid, row, col);\r\n        currentNode.isWall = true; \r\n        currentNodeElement.className = `node node-wall`;\r\n      }\r\n      else {\r\n        const weight = blockCoordinatesAndType[i][2];\r\n        grid = getNewGridWithWeightToggled(grid, row, col, weight);\r\n        currentNode.weight = weight;\r\n        currentNodeElement.className = `node node-weight-${weight}`;\r\n    \r\n      }\r\n    }\r\n    this.setState({grid: grid})\r\n  }\r\n\r\n  /**\r\n   * Clears only visited nodes that become unvisited when an endpoint is dragged.\r\n   * Utilized in visualizeNoAnimation() for its improved rendering efficiency\r\n   * over clearGrid()\r\n   */\r\n  clearVisitedNodes(){\r\n    const { grid } = this.state;\r\n    for (let row = 0; row < NUMROWS; row++) {\r\n      for (let col = 0; col < NUMCOLS; col++) {\r\n        const currentNode = grid[row][col];\r\n        const currentNodeElement = document.getElementById(\r\n          `node-${row}-${col}`\r\n        );\r\n        const className = currentNodeElement.className;\r\n        const startNode = this.state.startNode;\r\n        var tempClassName = null;\r\n        if (className === `node node-start` && (row !== startNode.row || col !== startNode.col)){\r\n          currentNodeElement.className = `node`;\r\n        }\r\n\r\n        if (currentNode.isVisited){\r\n          currentNode.isVisited = false;\r\n          // if (currentNode.weight > 1 && !(currentNode.isStart || currentNode.isFinish)) {\r\n          //   currentNodeElement.className = currentNodeElement.className + `node-weight-${currentNode.weight}`;\r\n          // }\r\n        }\r\n        else {\r\n          if (className === `node node-finish` &&\r\n              row !== this.state.finishNode.row &&\r\n              col !== this.state.finishNode.col){\r\n                currentNodeElement.className = `node`;\r\n              }\r\n          if (className === `node node-visited-no-animation node-weight-${currentNode.weight}` ||\r\n              className === `node node-shortest-path-no-animation node-weight-${currentNode.weight}`) {\r\n            currentNodeElement.className = `node node-weight-${currentNode.weight}`;\r\n          }\r\n\r\n          if (className !== `node node-start` &&\r\n              className !== `node node-finish` &&\r\n              className !== `node node-wall` &&\r\n              className !== `node node-shortest-path-no-animation node-weight-${currentNode.weight}` &&\r\n              className !== `node node-weight-${currentNode.weight}` &&\r\n              className !== `node node-visited node-weight-${currentNode.weight}`&&\r\n              className !== `node node-visited-no-animation node-weight-${currentNode.weight}`) {\r\n              if (currentNode.weight > 1) {\r\n                currentNodeElement.className = `node node-weight-${currentNode.weight}`;\r\n              }\r\n              else {\r\n              currentNodeElement.className = `node`;\r\n              }\r\n            }\r\n          }\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: grid,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Used in visualizeNoAnimation() to allow the algorithm to run with the \r\n   * new start and end nodes and a fresh grid.\r\n   */\r\n  resetNodeProperties(){\r\n    const { grid } = this.state;\r\n    for (let row = 0; row < NUMROWS; row++) {\r\n      for (let col = 0; col < NUMCOLS; col++) {\r\n        const currentNode = grid[row][col];\r\n        currentNode.isVisited = false;\r\n        currentNode.previousNode = null;\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Used in handleMouseEnter(), removes duplicate start/end nodes\r\n   * that appear when dragging the endpoints too quickly on empty grid.\r\n     */\r\n  clearStartAndFinishDuplicates(){\r\n    for (let row = 0; row < NUMROWS; row++) {\r\n      for (let col = 0; col < NUMCOLS; col++) {\r\n        const currentNodeElement = document.getElementById(\r\n          `node-${row}-${col}`\r\n        );\r\n        const startNode = this.state.startNode;\r\n        const finishNode = this.state.finishNode;\r\n        const className = currentNodeElement.className;\r\n        if (className === `node node-start` &&\r\n            (row !== startNode.row || col !== startNode.col )) {\r\n              currentNodeElement.className = `node`;\r\n        }\r\n        if (className === `node node-finish` &&\r\n        (row !== finishNode.row || col !== finishNode.col )) {\r\n          currentNodeElement.className = `node`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used in visualizeAlgorithm() with animation and Clear Grid button on the UI.\r\n   */\r\n  clearGrid() {\r\n    const grid = this.getEmptyGrid();\r\n    for (let row = 0; row < NUMROWS; row++) {\r\n      for (let col = 0; col < NUMCOLS; col++) {\r\n        const currentNode = this.createNode(col, row);\r\n        const currentNodeElement = document.getElementById(\r\n          `node-${row}-${col}`\r\n        );\r\n        const extraClassName = currentNode.isFinish\r\n          ? \"node-finish\"\r\n          : currentNode.isStart\r\n          ? \"node-start\"\r\n          : currentNode.isWall\r\n          ? \"node-wall\"\r\n          : \"node\";\r\n        currentNodeElement.className = `node ${extraClassName}`;\r\n      }\r\n    }\r\n\r\n    this.setState({\r\n      grid: grid,\r\n      algorithmAlreadyVisualized: false,\r\n    });\r\n\r\n  }\r\n\r\n  fillGridWithWalls() {\r\n    setTimeout(() => {\r\n    this.clearGrid();\r\n      }, 0);\r\n    setTimeout(() => {\r\n    const { grid } = this.state;\r\n    this.setState({disableButtonsAndGridWhileAnimating: true});\r\n    const visitedWallInOrder = mazeAlgorithm(grid, grid[1][0]);\r\n    this.placeFillerWalls(visitedWallInOrder);\r\n    }, 0);\r\n  }\r\n\r\n  placeFillerWalls(visitedWallsInOrder) { \r\n    for (let i = 0; i < visitedWallsInOrder.length; i++) {\r\n      setTimeout(() => {\r\n      const currentNode = visitedWallsInOrder[i];\r\n      const currentNodeElement = document.getElementById(\r\n        `node-${currentNode.row}-${currentNode.col}`\r\n      );\r\n      currentNodeElement.className = `node node-wall`;\r\n      }, i * 40);\r\n    }\r\n    setTimeout(() => {\r\n      this.setState({disableButtonsAndGridWhileAnimating: false});\r\n    }, 40 * visitedWallsInOrder.length);\r\n  }\r\n\r\n  /**\r\n   * Utilized to create unaltered Nodes during the creation of the grid in getEmptyGrid() and\r\n   * during the clearing of the grid in clearGrid().\r\n   * @param {int} col \r\n   * @param {int} row \r\n   * @returns {Node}\r\n   */\r\n  createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.startNode.row && col === this.state.startNode.col,\r\n      isFinish: row === this.state.finishNode.row && col === this.state.finishNode.col,\r\n      distance: Infinity,\r\n      weight: 1,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Construct a default grid object with unaltered Nodes.\r\n   * @returns {Array.<Array.<Node>>}\r\n   *  2D array of Nodes representing the grid\r\n   */\r\n  getEmptyGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < NUMROWS; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < NUMCOLS; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  \r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    const algorithmDropdownList = [\"Dijkstra\", \"A Star\", \"Breadth First\", \"Depth First\"];\r\n    const blockDropdownList = [\"Wall\", \"Weight\"];\r\n    const defaultDropdownTitles = [\"Choose Algorithm\", \"Block Type\"]\r\n    return (\r\n      <><div className=\"buttons\">\r\n          <button onClick={this.visualizeAlgorithm} disabled={this.state.disableButtonsAndGridWhileAnimating}>Visualize Algorithm</button>\r\n          <button onClick={this.clearGrid} disabled={this.state.disableButtonsAndGridWhileAnimating}>Clear Grid</button>\r\n          <DropdownMenu \r\n            key={1}\r\n            handler={this.handleChooseAlgorithm} \r\n            listItems={algorithmDropdownList} \r\n            defaultTitle={defaultDropdownTitles[0]}\r\n            extraClassName={\"algorithms\"}\r\n          />\r\n          <DropdownMenu\r\n            key={2}\r\n            handler={this.handleChooseBlockType} \r\n            listItems={blockDropdownList} \r\n            defaultTitle={defaultDropdownTitles[1]}            \r\n            extraClassName={\"blocks\"}\r\n\r\n          />\r\n          <button onClick={this.fillGridWithWalls} disabled={this.state.disableButtonsAndGridWhileAnimating}>Fill Grid</button>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall, weight } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      row={row}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      weight={weight}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={this.handleMouseDown.bind(this, row, col)}\r\n                      onMouseEnter={this.handleMouseEnter.bind(this, row, col)}\r\n                      onMouseUp={this.handleMouseUp.bind(this)}\r\n                      ref={this.ref}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isVisited: false,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWeightToggled = (grid, row, col, newWeight) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  var weight = node.weight + 1;\r\n  if (node.weight === 4){\r\n    weight = 1;\r\n  }\r\n  else if (newWeight > 0) {\r\n    weight = newWeight;\r\n  }\r\n  const newNode = {\r\n    ...node,\r\n    weight: weight,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathfindingVisualizer from \"./MazeSolvingVisualizer/PathfindingVisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\" id=\"visualizer\">\r\n      <PathfindingVisualizer />\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}